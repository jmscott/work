#!/usr/bin/env bash
#
#  Synopsis:
#	Build a tar or populate makefile from a shell sourcable config file.
#  Usage:
#	make-dist --help
#	make-dist --template >foobar.dist
#	vi foobar.dist
#
#	make-dist foobar.dist
#	D=$(pwd)
#	cd /usr/local/foobar && tar xvf $D/foobar-20140403_1213.tar.bz2
#
#	#  Makefile variables can be extracted from the the root.dist file
#	#  with these recipes.  Example make code follows:
#
#		DIST=product.dist
#		COMPILEs := $(shell  (. ./$(DIST) && echo $$COMPILEs))
#		SBINs := $(shell  (. ./$(DIST) && echo $$SBINs))
#		LIBs := $(shell  (. ./$(DIST) && echo $$LIBs))
#		SRCs := $(shell  (. ./$(DIST) && echo $$SRCs))
#
#	Config variables to create directories are these:
#
#		ARCHIVE=""
#		ATTIC=""
#		BINs="[files] ..."
#		CACHE=""
#		CGIBINs="[files] ..."
#		DATA=""
#		ETC=""
#		HTDOCSs="[files] ..."
#		LIBEXECs="[files] ..."
#		LIBs="[files] ..."
#		LOG=""
#		RUN=""
#		SBINs="[files] ..."
#		SPOOL=""
#		SRCs="[files] ..."
#		TMP=""
#		SYM
#
#	Empty string implies directory is created, if needed.
#	Any files
#
#  See:
#	https://github.com/jmscott/work/blob/master/make-dist
#	https://en.wikipedia.org/wiki/Unix_filesystem
#  Note:
#	- The tar version insures that dynamic directories in foobar.conf
#	exist but does NOT ever overwrite, lest precious data be lost.
#	However, the Makefile version, does not insure, so make recipes
#	must be hand coded.  Adding an option to generate the install
#	recipes would be nice:
#
#		make-dist dynamic-dirs
#
#	Which could be manually spliced back into the Makefile.
#
#	- Add command "env" or "fs" to document environment variables in config
#	file that describe directories.
#	
#	Think deepky about recursive version that can combine *.dist files
#
#	Why are the dirs/ for copy_file() hardwired for BINs, SBINs, etc?
#	Should not thast list be derived from the dist file?
#
#	Add "unpack" action, which properly removes and unpacks *.tar.bz2
#	directories.  Will need to make no assumptions about the root directory
#	files.  In other words, if, say, dir sbin/ is not in the tar file,
#	then "unpack" would NOT remove an existing /sbin/ on the target.
#	This algorithm implies knowing the difference between static dirs
#	like /sbin/, /lib/, etc versus dynatic dirs like /run/, /spool/.
#	Perhaps if the directory is empty in the tar file, then we can
#	safely assume the directory is dynamic and NOT to be removed on the
#	target.
#
die()
{
	echo "$PROG: ERROR: $@" >&2
	echo "usage: $USAGE"
	exit 1
}

[ "${BASH_VERSINFO:-0}" -ge 4 ] 					||
	die "bash version must be >= 4: ver ${BASH_VERSINFO:-0}" 

#  map directory name to create permisions.

declare -A dir2perm=(
	[archive]='u=wrx,go='
	[attic]='u=wrx,go='
	[bin]='u=rwx,g=rx,o='
	[cache]='u=wrx,go='
	[cgi-bin]='u=rwx,g=rx,o='
	[data]='u=wrx,go='
	[etc]='u=wrx,g=rx,o='
	[htdocs]='u=wrx,g=rx,o='
	[lib]='u=rwx,g=rx,o='
	[libexec]='u=rwx,g=rx,o='
	[log]='u=wrx,g=rx,o='
	[run]='u=wrx,go='
	[sbin]='u=rwx,go='
	[spool]='u=wrx,go='
	[src]='u=rwx,g=rx,o='
	[tmp]='ug=wrx,o='
)

#  map directory name to copy file permisions.
declare -A file2perm=(
	[bin]='ug=rx,o='
	[cgi-bin]='ug=rx,o='
	[htdocs]='ug=r,o='
	[lib]='ug=r,o='
	[libexec]='ug=rx,o='
	[sbin]='u=rx,go='
	[src]='ug=r,o='
)

#  map VAR name to directory name
declare -A VAR2dir=(
	[ARCHIVE]='archive'
	[ATTIC]='attic'
	[BINs]='bin'
	[CACHE]='cache'
	[CGIBINs]='cgi-bin'
	[DATA]='data'
	[ETC]='etc'
	[HTDOCSs]='htdocs'
	[LIBEXECs]='libexec'
	[LIBs]='lib'
	[LOG]='log'
	[RUN]='run'
	[SBINs]='sbin'
	[SPOOL]='spool'
	[SRCs]='src'
	[TMP]='tmp'
)

declare -A VAR2dir_local

PROG=$(basename $0)
USAGE="$PROG <help | template | tar> [distribution-file]"

help()
{
	cat <<END

Synopsis:
	Create a tar distro for a typical SystemV unix file system layout.
Usage:
	$USAGE
Description:
	$PROG reads a configuration file and builds a bzipped tar file of the 
	files in a typical unix directory layout.  The configuration file
	contains bourne shell variable definitions.  The tar file is 
	suitable for manually unpacking to install or upgrade a target host.  
	The files rebuilt in the tar archive into the following sub
	directories:
	
		 bin/	#  read only executables executed by cli or scripts
		sbin/	#  read only executables executed by daemons/services.
		 src/	#  compilable source code, not scripts.
	         lib/	#  read only support files.  typically sql scripts,
			#    perl libraries, etc.
	     libexec/	#  hidden executables, typically called from scripts.
	     cgi-bin/	#  cgi-scripts for web server
	      htdocs/	#  htdoc scripts for web server

	In the configuration file are environment variables BINs, CGIBINs, 
	LIBs, SBINs and HTDOCSs that contain the source file list for
	each target directory.  Also, empty directories may be created
	when the variables SPOOL, RUN, ETC, LOG, TMP, DATA and CACHE exist.
	Do make-dist --template for the list of all variables recognized.

	The compressed tar file is written into a file named 

		$DIST_TAR-YYYYMMDD_HHmm.tar.bz2.

	where default DIST_TAR=$(basename <dist> .dist)-YYYMMDD_HHMM.tar

Exit Status:
	0	no error
	1	error, temp build directory, named ./tmp/make-dist.\$\$,
			remains intact for debugging.
END
}


is_readable()
{
	VAR=$1
	CMD='FILES=$(echo $'$VAR')'
	eval $CMD
	for F in $FILES;  do
		test -r $F || die "$VAR: can't read file $F"
	done
}

make_SYMLINKs()
{
	test -n "$SYMLINKs" || return
	for S in $SYMLINKs;  do
		echo $S | fgrep -e '->' | sed 's/->/ /' | while read A B;  do
		echo "+$B -> $A" && (
			cd $WORK_TMP				||
				die "cd symlink failed: exit status=$?"
			BD=$(dirname $B)
			if [ ! -d $BD ];  then
				echo "+$BD"
				#  no permisions!!!
				mkdir $BD || die "mkdir failed: exit status=$?"
			fi
			ln -sf $A $B				||
				die "ln -fs failed: exit status=$?"
		)
		done
	done
}

#
#  Recursively copy files defined in a shell variable to a target directory
#  in the staging tree.
#
copy_file()
{
	VAR=$1;		shift
	DIR="${VAR2dir[$VAR]}"
	PERMD="${dir2perm[$DIR]}"
	PERMF="${file2perm[$DIR]}"

	#
	#  Echo the value of the variable whose name is $VAR.
	#
	CMD='FILEs=$(echo $'$VAR')'
	eval $CMD

	if [ ! "$FILEs" ];  then
		echo "-$DIR"
		return
	fi
	#
	#  Make the staging directory.
	#
	echo "+$DIR"
	mkdir -p $WORK_TMP/$DIR				||
		die "copy_file: mkdir stage root failed: exit status=$?"
	#
	#  Copy the files and directories into the staging directory
	#
	for F in $FILEs;  do
 		#
		#  The config file has a directory entry,
		#  so just make the directory.
		#
		if [ -d $F ];  then
			echo "+$DIR/$F/"
			DN=$WORK_TMP/$DIR/$F
			mkdir -p $DNq					||
				die "copy_file: mkdir config failed: "	\
					"exit status=$?"
			continue
		fi

		#
		#  The file lives in an uncreated directory.
		#
		DN=$(dirname $F | sed "s/^$DIR\///" | sed "s/^$DIR$//")
		if [ "$DN" -a ! -d $WORK_TMP/$DIR/$DN ];  then
			echo "+$DIR/$DN/"
			D="$WORK_TMP/$DIR/$DN"
			mkdir -p $D					||
				die "copy_file: mkdir failed: exit status=$?"
		fi
		#
		#  Derive the target directory path.
		#
		#  Eliminate the /./ directory path component
		#  for clarity.
		#
		case "$DN" in
		''|.)
			D=$DIR
			;;
		*)
			D="$DIR/$DN"
		esac
		#
		#  Ought to check fo existence of file before copy?
		#
		echo ">$D/$(basename $F)"
		cp $F $WORK_TMP/$D || die "copy_file: cp failed: exit status=$?"
	done

	#  set the permissions in the work temp directory

	find $WORK_TMP/$DIR -type d -print | xargs chmod $PERMD
	STATUS=${PIPESTATUS[*]}
	test "$STATUS" = '0 0'						||
		die "copy_file: find work dir | chmod failed:"		\
			"exit status=$STATUS"

	if [ "$FILEs" ];  then
		find $WORK_TMP/$DIR -type f -print | xargs chmod $PERMF
		STATUS=${PIPESTATUS[*]}
		test "$STATUS" = '0 0'					||
			die "find copy work | chmod failed: exit status=$STATUS"
	fi
}

#  Makefile an empty directory
make_dir()
{
	VAR=$1

	DIR="${VAR2dir[$VAR]}"
	EXISTS=$(eval "echo \${$VAR+$VAR}")
	case "$EXISTS" in
	$VAR)
		echo "+$DIR"
		;;
	'')
		echo "-$DIR"
		return
		;;
	*)
		die "make_dir: unexpected eval: $EXISTS"
		;;
	esac

	PERMD="${dir2perm[$DIR]}"
	test -n "$PERMD" || die "make_dir: no perms: $DIR"

	#
	#  Make the staging directory.
	#
	#  Note:  need to test for error!
	#
	mkdir -p $WORK_TMP/$DIR || die "make_dir: mkdir failed: exit status=$?"
	find $WORK_TMP/$DIR -type d -print | xargs chmod $PERMD
	STATUS=${PIPESTATUS[*]}
	test "$STATUS" = '0 0' ||
		die "make_dir: find dir | chmod failed: status=$STATUS"
}

test $# = 0 && die "wrong number of arguments"

ACTION="$1";  shift
case "$ACTION" in
help)
	help
	exit 0
	;;


template)
	cat <<END
#
#  Synopsis:
#	Configuration file read by make-dist to build tar files.
#  See:
#	https://github.com/jmscott/work/blob/master/make-dist
#  Note:
#	Makefile variables can be extracted and defined from the the
#	root.dist file with these recipes.  Example make code follows:
#
#		DIST=product.dist
#
#		COMPILEs := \$(shell  (. ./\$(DIST) && echo \$\$COMPILEs))
#		SBINs := \$(shell  (. ./\$(DIST) && echo \$\$SBINs))
#		LIBs := \$(shell  (. ./\$(DIST) && echo \$\$LIBs))
#		SRCs := \$(shell  (. ./\$(DIST) && echo \$\$SRCs))
#		BINs := \$(shell  (. ./\$(DIST) && echo \$\$BINs))
#		HTDOCSs := \$(shell  (. ./\$(DIST) && echo \$\$HTDOCSs))
#		CGIBINs := \$(shell  (. ./\$(DIST) && echo \$\$CGIBINs))
#		LIBEXEC := \$(shell  (. ./\$(DIST) && echo \$\$LIBEXECs))
#

#
#  Uncomment for compiled programs to be installed i bin/ or sbin/ and
#  removed in "clean" recipes.
#
#COMPILEs="
#"

LIBs="
"

#  Uncoment to create bin/ directory
#BINs="
#"

SBINs="
"

#  Uncomment to create tmp/ directory
#TMP="
#"

#  Uncomment to create cgibin/ directory
#CGIBINs="
#"

#  Uncomment to create htdocs/ directory
#HTDOCSs="
#"

#  Uncomment to create src/ directory
#SRCs="
#"

#  Uncomment to create attic/ directory
#ATTIC="
#"

#  Uncomment to create archive/ directory
#ARCHIVE="
#"

#  Uncomment to create etc/ directory
#ETC="
#"

#  Uncomment to create spool/ directory
#SPOOL="
#"

#  Uncomment to create data/ directory
#DATA="
#"

#  Uncomment to create run/ directory
#RUN="
#"

#  Uncomment to create log/ directory
#LOG="
#"

#  Uncomment to create cache/ directory
#CACHE="
#"

#  Uncomment to create directory libexec/
#LIBEXECs="
#"
END
	exit 0
	;;
tar)
	ACTION="$1";  shift
	;;
*.dist)
	DIST="$ACTION"
	;;
*)
	test -e "$ACTION" && die "dist file does not end in .dist: $ACTION"
	die "unknown action: $ACTION"
	;;
esac


DIST="$ACTION"
test -r "$DIST" || die "can't read dist file: $DIST"

#  Write a compresed tar file of the dist files.

#
#  Source in the configuration file.
#
. ./$DIST

#  map local VAR declarations to new directory paths
for key in "${!VAR2dir_local[@]}"; do
	VAR2dir[$key]="${VAR2dir_local[$key]}"
	echo "+$key->${VAR2dir[$key]}"
done

#
#  TAR_FILE is basename of directory, by default;
#  otherwise, whatever is set in the configuration file.
#
TAR_FILE=$(basename $DIST .dist)

echo "# tar file is $TAR_FILE"

#
#  Verify that files are readable.
#
is_readable BINs
is_readable CGIBINs
is_readable HTDOCSs
is_readable LIBEXECs
is_readable LIBs
is_readable SBINs

#
#  Make temporary work directory.
#
WORK_TMP=tmp/$PROG.$$
test -d $WORK_TMP && die "tmp directory $WORK_TMP already exists"
mkdir -p $WORK_TMP || die "mkdir -p $WORK_TMP failed"
echo ">$WORK_TMP"

#
#  Copy files in various staging directories
#
#	copy_file VAR dir dir_perms file_perms
#
#  Does the order of the directories matter?
#  Probably ought to be the order defined in the file.
#
copy_file BINs
copy_file CGIBINs
copy_file HTDOCSs
copy_file LIBEXECs
copy_file LIBs
copy_file SBINs
copy_file SRCs

#  make directories, if variables defined in distribution file

make_dir ARCHIVE
make_dir ATTIC
make_dir BINs
make_dir CACHE
make_dir CGIBINs
make_dir DATA
make_dir ETC
make_dir HTDOCSs
make_dir LIBEXECs
make_dir LIBs
make_dir LOG
make_dir RUN
make_dir SBINs
make_dir SPOOL
make_dir SRCs
make_dir TMP

make_SYMLINKs 

#
#  Tar up files into $TAR_FILE-YYYYMMDD_hhmm.tar.bz2
#
TAR_FILE=$TAR_FILE-$(date +'%Y%m%d_%H%M').tar.bz2
echo ">$TAR_FILE"
(
	cd $WORK_TMP || die "cd $WORK_TMP failed"
	#
	#  Tar up files in scratch directory.
	#  Need to check tar error status with ${PIPSTATUS[]}.
	#
	tar cf - $(find . -mindepth 1 -maxdepth 1 -type d)		||
		die "tar cf failed: exit status=$?"
) | bzip2 --best >$TAR_FILE
STATUS=${PIPESTATUS[*]}
test "$STATUS" = '0 0'							||
	die "tar | bzip2 failed: exist status=$STATUS"

test -s $TAR_FILE || die "empty tar file $TAR_FILE"

#
#  Zap the temporary scratch dir.
#
#  Note:
#	What about zapping dir tmp/ upon certain common errors,
#	like missing files.
#
echo "-$WORK_TMP"
find $WORK_TMP ! -type l -print | xargs chmod +w
STATUS="${PIPESTATUS[*]}"
test "$STATUS" = '0 0' || die "find workd dir | chmod +w failed: "	\
			      "exist status=$?"
rm -rf $WORK_TMP || die "rm -rf $WORK_TMP failed"
exit 0
