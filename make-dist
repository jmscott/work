#!/bin/bash
#
#  Synopsis:
#	From a config file, create a tar distro for a typical SysV file system.
#  Usage:
#	make-dist --help
#	make-dist --template >root.dist
#	vi root.dist
#
#	make-dist setspace.dist
#	D=$(pwd)
#	cd /path/to/product/root && tar xvf $D/setspace-20140403_1213.tar.bz2
#
#	#  Makefile variables can be extracted from the the root.dist file
#	#  with these recipes
#
#       COMPILEs := $(shell  (. ./root.dist && echo $$COMPILEs))
#       SBINs := $(shell  (. ./root.dist && echo $$SBINs))
#       LIBs := $(shell  (. ./root.dist && echo $$LIBs))
#       SRCs := $(shell  (. ./root.dist && echo $$SRCs))
#
#  See:
#	https://github.com/jmscott/work/blob/master/make-dist
#	https://en.wikipedia.org/wiki/Unix_filesystem
#  Note:
#	Rename make-dist to make-tar-dist.
#
#	At least one file must exist in the root.dist file.	
#
#	What about moving the dynamic directories like tmp/ spool/
#	into var/?  Perhaps a variable VAR_DIR="spool data"?
#

PROG=$(basename $0)
USAGE="$PROG [--help] [--template] <distribution-file>"

help()
{
	cat <<END

Synopsis:
	Create a tar distro for a typical SystemV unix file system layout.
Usage:
	$USAGE
Description:
	$PROG reads a configuration file and builds a bzipped tar file of the 
	files in a typical unix directory layout.  The confiugration files
	contains bourne shell variable definitions.  The tar file is 
	suitable for unpacking to install or upgrade a target host.  
	The files rebuilt in the tar archive into the following sub
	directories:
	
		bin/	#  read only executables executed by cli or scripts
		sbin/	#  read only executables executed by daemons/services.
		src/	#  compilable source code, not scripts.
		lib/	#  read only support files.  typically sql scripts,
			#    perl libraries, etc.
	    cgi-bin/	#  cgi-scripts for web server
	     htdocs/	#  htdoc scripts for web server
		
	In the configuration file are environment variables BINs, CGIBINs, 
	LIBs, SBINs and HTDOCs that contain the source file list for
	each target directory.  Also, empty directories may be created
	when the variables SPOOL, RUN, ETC, LOG, TMP, DATA and CACHE exist.
	Do make-dist --template for the list of all variables recognized.

	The compressed tar file is written into a file named 

		$PRODUCT-YYYYMMDD_HHmm.tar.bz2.

	where PRODUCT is the $(basename $(pwd)).  To change the basename of
	the product, define the PRODUCT environment variable in the
	configuration file.

		PRODUCT=setspace

	To unpack the tar file on the production host, do something like

		scp \$PRODUCT-YYMMDD_HHMM.tar.bz2 \$PRODUCT@host:/tmp
		ssh \$PRODUCT@host
		cd <target-dir>
		bzcat /tmp/\$PRODUCT-YYMMDD_HHMM.tar.bz2 | tar xvf -
Exit Status:
	0	no error
	1	error, temp build directory, named ./tmp/make-dist.\$\$,
			left intact.
END
}

PRODUCT=$(basename $(pwd))

die()
{
	echo "$PROG: ERROR: $@" >&2
	echo "usage: $USAGE"
	exit 1
}

is_readable()
{
	VAR=$1
	CMD='FILES=$(echo $'$VAR')'
	eval $CMD
	for F in $FILES;  do
		test -r $F || die "$VAR: can't read file $F"
	done
}

#
#  Recursively copy files defined in a shell variable to a target directory
#  in the staging tree.
#
copy_files()
{
	VAR=$1;		shift
	DIR=$1;		shift
	PERMD=$1;	shift
	PERMF=$1;	shift

	#
	#  Echo the value of the variable whose name is $VAR.
	#
	CMD='FILEs=$(echo $'$VAR')'
	eval $CMD

	if [ ! "$FILEs" ];  then
		echo "-$DIR"
		return
	fi
	#
	#  Make the staging directory.
	#
	echo "+$DIR"
	mkdir -p $WORK_TMP/$DIR || die "$VAR: mkdir $WORK_TMP/$DIR failed"
	#
	#  Copy the files and directories into the staging directory
	#
	for F in $FILEs;  do
 		#
		#  The config file has a directory entry,
		#  so just make the directory.
		#
		if [ -d $F ];  then
			echo "+$DIR/$F/"
			DN=$WORK_TMP/$DIR/$F
			mkdir -p $DN || die "mkdir -p $DN failed"
			continue
		fi

		#
		#  The file lives in an uncreated directory.
		#
		DN=$(dirname $F | sed "s/^$DIR\///" | sed "s/^$DIR$//")
		if [ "$DN" -a ! -d $WORK_TMP/$DIR/$DN ];  then
			echo "+$DIR/$DN/"
			D="$WORK_TMP/$DIR/$DN"
			mkdir -p $D || die "mkdir -p $D failed"
		fi
		#
		#  Derive the target directory path.
		#
		#  Eliminate the /./ directory path component
		#  for clarity.
		#
		case "$DN" in
		''|.)
			D=$DIR
			;;
		*)
			D="$DIR/$DN"
		esac
		#
		#  Ought to check fo existence of file before copy?
		#
		echo ">$D/$(basename $F)"
		cp $F $WORK_TMP/$D || die "cp $F $WORK_TMP/$D failed"
	done

	#  Note:  need to test for error!

	find $WORK_TMP/$DIR -type d -print | xargs chmod $PERMD
	if [ "$FILEs" ];  then
		find $WORK_TMP/$DIR -type f -print | xargs chmod $PERMF
	fi
}

#  Makefile an empty directory, typical not for static data
make_dir()
{
	VAR=$1;		shift
	PERMD=$1;	shift

	DIR=$(echo $VAR | tr A-Z a-z)
	EXISTS=$(eval "echo \${$VAR+$VAR}")
	case "$EXISTS" in
	$VAR)
		echo "+$DIR"
		;;
	'')
		echo "-$DIR"
		return
		;;
	*)
		die "make_dir: unexpected eval: $EXISTS"
		;;
	esac

	#
	#  Make the staging directory.
	#
	#  Note:  need to test for error!
	#
	mkdir -p $WORK_TMP/$DIR || die "$VAR: mkdir $WORK_TMP/$DIR failed"
	find $WORK_TMP/$DIR -type d -print | xargs chmod $PERMD
}

test $# = 0 && die "wrong number of arguments"

#
#  Read the configuration file.
#
case "$1" in
'')
	die "wrong number of argument"
	;;
--help)
	help
	exit 0
	;;
--template)
	cat <<END
#
#  Synopsis:
#	Configuration file read by make-dist to build tar files.
#  See Also:
#	https://github.com/jmscott/work/blob/master/make-dist
#

#  Define PRODUCT to change from \$(basename \$(pwd))
#PRODUCT=foobar

LIBs="
"

BINs="
"

SBINs="
"

CGIBINs="
"

HTDOCs="
"

SRCs="
"

#  Uncomment to create etc/ directory
#ETC=""

#  Uncomment to create spool/ directory
#SPOOL=""

#  Uncomment to create data/ directory
#DATA=""

#  Uncomment to create run/ directory
#RUN=""

#  Uncomment to create log/ directory
#LOG=""

#  Uncomment to create cache/ directory
#CACHE=""

#  Uncomment to create tmp/ directory
#TMP=""

END
	exit 0
	;;
-*)
	die "unknown option: $1"
	;;
*)
	CONF="$1"
	test -r "$CONF" || die "can't read configuration file: $CONF"
	;;
esac

#
#  Source in the configuration file.
#
. ./$CONF

#
#  PRODUCT is basename of directory, by default;
#  otherwise, whatever is set in the configuration file.
#
PRODUCT=${PRODUCT:=$(basename $(pwd))}

echo "# product is $PRODUCT"

#
#  Verify that files are readable.
#
is_readable BINs
is_readable SBINs
is_readable CGIBINs
is_readable LIBs
is_readable HTDOCs

#
#  Make temporary work directory.
#
WORK_TMP=tmp/$PROG.$$
test -d $WORK_TMP && die "tmp directory $WORK_TMP already exists"
mkdir -p $WORK_TMP || die "mkdir -p $WORK_TMP failed"
echo ">$WORK_TMP"

#
#  Copy files in various staging directories
#
#	copy_files VAR dir dir_perms file_perms
#
#  Does the order of the directories matter?
#  Probably ought to be the order defined in the file.
#
copy_files BASEs . u=rwx,g=rx,o= ug=rx,o=
#
#  Shouldn't bin/ be readable by world?
#
copy_files BINs bin u=rwx,g=rx,o= ug=rx,o=
copy_files SBINs sbin u=rwx,go= u=rx,go=
copy_files CGIBINs cgi-bin u=rwx,g=rx,o= ug=rx,o=
copy_files LIBs lib u=rwx,g=rx,o= ug=r,o=
copy_files SRCs src u=rwx,g=rx,o= ug=r,o=
copy_files HTDOCs htdocs u=wrx,g=rx,o= ug=r,o=

#  make directories, if variables defined in distribution file

make_dir TMP ug=wrx,o=
make_dir SPOOL u=wrx,go=
make_dir RUN u=wrx,go=
make_dir DATA u=wrx,go=
make_dir CACHE u=wrx,go=
make_dir ETC u=wrx,g=rx,o=
make_dir LOG u=wrx,g=rx,o=

#
#  Tar up files into $PRODUCT-YYYYMMDD_HHmm.tar.bz2
#
TAR_FILE=$PRODUCT-$(date +'%Y%m%d_%H%M').tar.bz2
echo ">$TAR_FILE"
(
	cd $WORK_TMP || die "cd $WORK_TMP failed"
	#
	#  Tar up files in scratch directory.
	#  Need to check tar error status with ${PIPSTATUS[]}.
	#
	tar cf - $(find . -mindepth 1 -maxdepth 1 -type d)
) | bzip2 --best >$TAR_FILE
test -s $TAR_FILE || die "empty tar file $TAR_FILE"

#
#  Zap the temporary scratch dir.
#
#  Note:
#	What about zapping dir tmp/ upon certain common errors,
#	like missing files.
#
find $WORK_TMP -print | xargs chmod +x
rm -rf $WORK_TMP || die "rm -rf $WORK_TMP failed"
exit 0
