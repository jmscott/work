#!/usr/bin/env bash
#
#  Synopsis:
#	Build a tar using files/dirs defined in shell sourcable config file.
#  Usage:
#	make-dist --help
#	make-dist --template >foobar.dist
#	vi foobar.dist
#
#	make-dist foobar.dist
#	D=$(pwd)
#	cd /usr/local/foobar && tar xvf $D/foobar-20140403_1213.tar.bz2
#
#	#  Makefile variables can be extracted from the the root.dist file
#	#  with these recipes.  Example make code follows:
#
#		DIST=product.dist
#		COMPILEs := $(shell  (. ./$(DIST) && echo $$COMPILEs))
#		SBINs := $(shell  (. ./$(DIST) && echo $$SBINs))
#		LIBs := $(shell  (. ./$(DIST) && echo $$LIBs))
#		SRCs := $(shell  (. ./$(DIST) && echo $$SRCs))
#		INCLUDEs := $(shell  (. ./$(DIST) && echo $$INCLUDEs))
#
#	Config variables to create directories bit not touch contents are:
#
#		ARCHIVE=""
#		ATTIC=""
#		BINs="[files] ..."
#		CACHE=""
#		CGIBINs="[files] ..."
#		DATA=""
#		DIST=""
#		ETC=""
#		HTDOCSs="[files] ..."
#		LIBEXECs="[files] ..."
#		LIBs="[files] ..."
#		LOG=""
#		RUN=""
#		SBINs="[files] ..."
#		SPOOL=""
#		SRCs="[files] ..."
#		TMP=""
#		SYM
#
#	Empty string implies directory is created, if needed.
#	Any files
#  See:
#	https://github.com/jmscott/work/blob/master/make-dist
#	https://en.wikipedia.org/wiki/Unix_filesystem
#  Note:
#	Added variable TAR_FILE_BASE to replace var PRODUCT.
#
#	Add startup test for GNU sed!
#
#	- VAR->dir remaps only for a single directory.  for example,
#
#		LIBs->lib/schema
#
#	- The tar version insures that dynamic directories in foobar.conf
#	exist but does NOT ever overwrite, lest precious data be lost.
#	However, the Makefile version, does not insure, so make recipes
#	must be hand coded.  Adding an option to generate the install
#	recipes would be nice:
#
#		make-dist dynamic-dirs
#
#	Which could be manually spliced back into the Makefile.
#
#	- Add command "env" or "fs" to document environment variables in config
#	file that describe directories.
#	
#	Think deepky about recursive version that can combine *.dist files
#
#	Why are the dirs/ for copy_file() hardwired for BINs, SBINs, etc?
#	Should not thast list be derived from the dist file?
#
#	Add "unpack" action, which properly removes and unpacks *.tar.bz2
#	directories.  Will need to make no assumptions about the root directory
#	files.  In other words, if, say, dir sbin/ is not in the tar file,
#	then "unpack" would NOT remove an existing /sbin/ on the target.
#	This algorithm implies knowing the difference between static dirs
#	like /sbin/, /lib/, etc versus dynatic dirs like /run/, /spool/.
#	Perhaps if the directory is empty in the tar file, then we can
#	safely assume the directory is dynamic and NOT to be removed on the
#	target.
#

leave()
{
	if [ -n "$WORK_TMP" -a -d $WORK_TMP ];  then
		rm -rf $WORK_TMP					||
			echo "WARN: rm work tmp failed: exit status=$?"
	fi
}

trap leave EXIT QUIT TERM

die()
{
	echo "$PROG: ERROR: $@" >&2
	echo "usage: $USAGE"
	exit 1
}

[ "${BASH_VERSINFO:-0}" -ge 4 ] 					||
	die "bash version must be >= 4: ver ${BASH_VERSINFO:-0}" 

#  map directory name to create permisions.

declare -A dir2perm=(
	[archive]='u=wrx,go='
	[attic]='u=wrx,go='
	[bin]='u=rwx,g=rx,o='
	[cache]='u=wrx,go='
	[cgi-bin]='u=rwx,g=rx,o='
	[data]='u=wrx,go='
	[dist]='u=wrx,go='
	[etc]='u=wrx,g=rx,o='
	[htdocs]='u=wrx,g=rx,o='
	[include]='u=rwx,go=rx'
	[lib]='u=rwx,go=rx'
	[libexec]='u=rwx,go=rx'
	[log]='u=wrx,g=rx,o='
	[run]='u=wrx,go='
	[sbin]='u=rwx,go='
	[spool]='u=wrx,go='
	[src]='u=rwx,g=rx,o='
	[tmp]='ug=wrx,o='
)

#  map directory name to copy file permisions.
declare -A file2perm=(
	[bin]='ug=rx,o='
	[cgi-bin]='ug=rx,o='
	[htdocs]='ug=r,o='
	[include]='ugo=r'
	[lib]='ugo=r'
	[libexec]='ugo=rx'
	[sbin]='u=rx,go='
	[src]='ugo=r'
)

#  map VAR name to directory name
declare -A VAR2dir=(
	[ARCHIVE]='archive'
	[ATTIC]='attic'
	[BINs]='bin'
	[CACHE]='cache'
	[CGIBINs]='cgi-bin'
	[DATA]='data'
	[DIST]='dist'
	[ETC]='etc'
	[HTDOCSs]='htdocs'
	[INCLUDEs]='include'
	[LIBEXECs]='libexec'
	[LIBs]='lib'
	[LOG]='log'
	[RUN]='run'
	[SBINs]='sbin'
	[SPOOL]='spool'
	[SRCs]='src'
	[TMP]='tmp'
)

declare -A VAR2dir_local

PROG=$(basename $0)
USAGE="$PROG <help | template | tar> [product.dist]"

is_readable()
{
	VAR=$1
	CMD='FILES=$(echo $'$VAR')'
	eval $CMD
	for F in $FILES;  do
		test -r $F || die "$VAR: can't read file $F"
	done
}

make_SYMLINKs()
{
	test -n "$SYMLINKs" || return
	for S in $SYMLINKs;  do
		echo $S | fgrep -e '->' | sed 's/->/ /' | while read A B;  do
		echo "+$B -> $A" && (
			cd $WORK_TMP				||
				die "cd symlink failed: exit status=$?"
			BD=$(dirname $B)
			if [ ! -d $BD ];  then
				echo "+$BD"
				#  no permisions!!!
				mkdir -p $BD				||
					die 'make_SYMLINKs: mkdir failed: '\
					     "exit status=$?"
			fi
			ln -sf $A $B || die "ln -fs failed: exit status=$?"
		)
		done
	done
}

#
#  Recursively copy files defined in a shell variable to a target directory
#  in the staging tree.
#
copy_file()
{
	VAR=$1;		shift
	DIR="${VAR2dir[$VAR]}"
	PERMD="${dir2perm[$DIR]}"
	PERMF="${file2perm[$DIR]}"

	#
	#  Echo the value of the variable whose name is $VAR.
	#
	CMD='FILEs=$(echo $'$VAR')'
	eval $CMD

	if [ ! "$FILEs" ];  then
		echo "-$DIR"
		return
	fi
	#
	#  Make the staging directory.
	#
	echo "+$DIR"
	mkdir -p $WORK_TMP/$DIR				||
		die "copy_file: mkdir stage root failed: exit status=$?"
	#
	#  Copy the files and directories into the staging directory
	#
	for F in $FILEs;  do
 		#
		#  The config file has a directory entry,
		#  so just make the directory.
		#
		if [ -d $F ];  then
			echo "+$DIR/$F/"
			DN=$WORK_TMP/$DIR/$F
			mkdir -p $DN					||
				die "copy_file: mkdir config failed: "	\
					"exit status=$?"
			continue
		fi

		#
		#  The file lives in an uncreated directory.
		#
		DN=$(dirname $F | sed "s:^$DIR\/::" | sed "s:^$DIR$::")
		if [ "$DN" -a ! -d $WORK_TMP/$DIR/$DN ];  then
			echo "+$DIR/$DN/"
			D="$WORK_TMP/$DIR/$DN"
			mkdir -p $D					||
				die "copy_file: mkdir failed: exit status=$?"
		fi
		#
		#  Derive the target directory path.
		#
		#  Eliminate the /./ directory path component
		#  for clarity.
		#
		case "$DN" in
		''|.)
			D=$DIR
			;;
		*)
			D="$DIR/$DN"
		esac
		#
		#  Ought to check fo existence of file before copy?
		#
		echo ">$D/$(basename $F)"
		cp $F $WORK_TMP/$D || die "copy_file: cp failed: exit status=$?"
	done

	#  set the permissions in the work temp directory

	find $WORK_TMP/$DIR -type d -print | xargs chmod $PERMD
	STATUS=${PIPESTATUS[*]}
	test "$STATUS" = '0 0'						||
		die "copy_file: find work dir | chmod failed:"		\
			"exit status=$STATUS"

	if [ "$FILEs" ];  then
		find $WORK_TMP/$DIR -type f -print | xargs chmod $PERMF
		STATUS=${PIPESTATUS[*]}
		test "$STATUS" = '0 0'					||
			die "find copy work | chmod failed: exit status=$STATUS"
	fi
}

#  Makefile an empty directory
make_dir()
{
	VAR=$1

	DIR="${VAR2dir[$VAR]}"
	EXISTS=$(eval "echo \${$VAR+$VAR}")
	case "$EXISTS" in
	$VAR)
		echo "+$DIR"
		;;
	'')
		echo "-$DIR"
		return
		;;
	*)
		die "make_dir: unexpected eval: $EXISTS"
		;;
	esac

	PERMD="${dir2perm[$DIR]}"
	test -n "$PERMD" || die "make_dir: no perms: $DIR"

	#
	#  Make the staging directory.
	#
	#  Note:  need to test for error!
	#
	mkdir -p $WORK_TMP/$DIR || die "make_dir: mkdir failed: exit status=$?"
	find $WORK_TMP/$DIR -type d -print | xargs chmod $PERMD
	STATUS=${PIPESTATUS[*]}
	test "$STATUS" = '0 0' ||
		die "make_dir: find dir | chmod failed: status=$STATUS"
}

test $# = 0 && die "wrong number of arguments"

ACTION="$1";  shift
case "$ACTION" in
help)
	exec $JMSCOTT_ROOT/libexec/make-dist-help
	exit 0
	;;


template)
	exec cat $JMSCOTT_ROOT/lib/make-dist-template.dist
	exit 0
	;;
tar)
	ACTION="$1";  shift
	;;
*.dist)
	DIST="$ACTION"
	;;
*)
	test -e "$ACTION" && die "dist file does not end in .dist: $ACTION"
	die "unknown action: $ACTION"
	;;
esac

DIST="$ACTION"
test -r "$DIST" || die "can't read dist file: $DIST"

#  Write a compresed tar file of the dist files.

#
#  Source in the configuration file.
#
. ./$DIST

#  remap local VAR declarations to new directory paths

for V in "${!VAR2dir_local[@]}"; do
	ORIG_D="${VAR2dir[$V]}"
	test -n "$ORIG_D" || die "can not map original var to directory: $V"

	PERMD="${dir2perm[$ORIG_D]}"
	test -n "$PERMD" || die "no perms for original dir: $ORIG_D"
	PERMF="${file2perm[$ORIG_D]}"
	test -n "$PERMF" || die "no perms for original dir/file: $ORIG_D"

	NEW_D="${VAR2dir_local[$V]}"
	VAR2dir[$V]="$NEW_D"
	dir2perm[$NEW_D]="$PERMD"
	file2perm[$NEW_D]="$PERMF"
	echo "+$V->${VAR2dir[$V]} ($PERMD) ($PERMF)"

done

#
#  TAR_FILE is basename of directory, by default;
#  otherwise, whatever is set in the configuration file.
#
TAR_FILE=$(basename $DIST .dist)

echo "# tar file is $TAR_FILE"

#
#  Verify that files are readable.
#
is_readable BINs
is_readable CGIBINs
is_readable HTDOCSs
is_readable INCLUDEs
is_readable LIBEXECs
is_readable LIBs
is_readable SBINs

#
#  Make temporary work directory.
#
WORK_TMP=tmp/$PROG.$$
test -d $WORK_TMP && die "tmp directory $WORK_TMP already exists"
mkdir -p $WORK_TMP || die "mkdir -p $WORK_TMP failed"
echo ">$WORK_TMP"

#  make directories, if variables defined in distribution file

make_dir ARCHIVE
make_dir ATTIC
make_dir BINs
make_dir CACHE
make_dir CGIBINs
make_dir DATA
make_dir DIST
make_dir ETC
make_dir HTDOCSs
make_dir INCLUDEs
make_dir LIBEXECs
make_dir LIBs
make_dir LOG
make_dir RUN
make_dir SBINs
make_dir SPOOL
make_dir SRCs
make_dir TMP

#
#  Copy files in various staging directories
#
#	copy_file VAR dir dir_perms file_perms
#
#  Does the order of the directories matter?
#  Probably ought to be the order defined in the file.
#
copy_file BINs
copy_file CGIBINs
copy_file HTDOCSs
copy_file INCLUDEs
copy_file LIBEXECs
copy_file LIBs
copy_file SBINs
copy_file SRCs

make_SYMLINKs 

#
#  Tar up files into $TAR_FILE-YYYYMMDD_hhmm.tar.bz2
#
TAR_FILE=$TAR_FILE-$(date +'%Y%m%d_%H%M').tar.bz2
echo ">$TAR_FILE"
(
	cd $WORK_TMP || die "cd $WORK_TMP failed"
	#
	#  Tar up files in scratch directory.
	#  Need to check tar error status with ${PIPSTATUS[]}.
	#
	tar cf - $(find . -mindepth 1 -maxdepth 1 -type d)		||
		die "tar cf failed: exit status=$?"
) | bzip2 --best >$TAR_FILE
STATUS=${PIPESTATUS[*]}
test "$STATUS" = '0 0'							||
	die "tar | bzip2 failed: exist status=$STATUS"

test -s $TAR_FILE || die "empty tar file $TAR_FILE"

#
#  Zap the temporary scratch dir.
#
#  Note:
#	What about zapping dir tmp/ upon certain common errors,
#	like missing files.
#
echo "-$WORK_TMP"
find $WORK_TMP ! -type l -print | xargs chmod +w
STATUS="${PIPESTATUS[*]}"
test "$STATUS" = '0 0' || die "find work tmp dir | chmod +w failed: "	\
			      "exit status=$?"

rm -rf $WORK_TMP || die "rm -rf $WORK_TMP failed"
exit 0
